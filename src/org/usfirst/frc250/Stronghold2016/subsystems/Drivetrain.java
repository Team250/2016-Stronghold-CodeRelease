// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.Stronghold2016.subsystems;

import org.usfirst.frc250.Stronghold2016.Constant;
import org.usfirst.frc250.Stronghold2016.RobotMap;
import org.usfirst.frc250.Stronghold2016.commands.driving.Drive;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class Drivetrain extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon left1 = RobotMap.drivetrainleft1;
    private final CANTalon left2 = RobotMap.drivetrainleft2;
    private final CANTalon right1 = RobotMap.drivetrainright1;
    private final CANTalon right2 = RobotMap.drivetrainright2;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private boolean reverseMode;

	public Drivetrain() {
		left1.setFeedbackDevice(CANTalon.FeedbackDevice.QuadEncoder);
		right1.setFeedbackDevice(CANTalon.FeedbackDevice.QuadEncoder);
		left1.enableBrakeMode(true);
		right1.enableBrakeMode(true);
		left2.enableBrakeMode(true);
		right2.enableBrakeMode(true);
		left2.changeControlMode(CANTalon.TalonControlMode.Follower);
		left2.set(left1.getDeviceID());
		right2.changeControlMode(CANTalon.TalonControlMode.Follower);
		right2.set(right1.getDeviceID());
		right1.setInverted(true);
		right1.reverseOutput(true);
		right1.reverseSensor(true);
		left1.setVoltageRampRate(Constant.kDRIVE_RAMP_RATE.get());
		right1.setVoltageRampRate(Constant.kDRIVE_RAMP_RATE.get());
		reverseMode = false;
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());

        setDefaultCommand(new Drive());
	}

	/**
	 * Tank drive given two joystick inputs. Will be reversed if
	 * {@link #toggleReverseMode()} is called.
	 * 
	 * @param left
	 *            Left side speed, from -1 to 1.
	 * @param right
	 *            Right side speed, from -1 to 1.
	 */
	public void drive(double left, double right) {
		if (reverseMode) {
			left1.set(-right * Constant.kDRIVE_MULTIPLIER.get());
			right1.set(-left * Constant.kDRIVE_MULTIPLIER.get());
		} else {
			left1.set(left * Constant.kDRIVE_MULTIPLIER.get());
			right1.set(right * Constant.kDRIVE_MULTIPLIER.get());
		}
	}

	/**
	 * Stops all driving.
	 */
	public void stopDriving() {
		drive(0, 0);
	}

	/**
	 * Returns whether or not the driving controls are currently reversed.
	 * 
	 * @return Whether the driving controls are reversed.
	 */
	public boolean isReverseMode() {
		return reverseMode;
	}

	/**
	 * Reverses the current driving controls. Forward becomes backward and vice
	 * versa.
	 */
	public void toggleReverseMode() {
		reverseMode = !reverseMode;
	}

	/**
	 * Enable brake or coast mode for all motors.
	 * 
	 * @param isBrake
	 *            True for brake, false for coast.
	 */
	public void enableBrakeMode(boolean isBrake) {
		left1.enableBrakeMode(isBrake);
		right1.enableBrakeMode(isBrake);
		left2.enableBrakeMode(isBrake);
		right2.enableBrakeMode(isBrake);
	}

	/**
	 * Returns whether the motors are currently in brake mode, the alternative
	 * being coast.
	 * 
	 * @return Whether the motors are in brake mode.
	 */
	public boolean isBrakeMode() {
		return left1.getBrakeEnableDuringNeutral();
	}
}
