// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.Stronghold2016.subsystems;

import org.usfirst.frc250.Stronghold2016.Constant;
import org.usfirst.frc250.Stronghold2016.Robot;
import org.usfirst.frc250.Stronghold2016.RobotMap;
import org.usfirst.frc250.Stronghold2016.Utilities;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class Miscellany extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final PowerDistributionPanel pdp = RobotMap.miscellanypdp;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final AHRS purpleSensor = RobotMap.miscellanyPurpleSensor;

	public Miscellany () {
		lightsInit();
	}
	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	// ==== GYRO ====
	
	private double offset = 0;
	
	/**
	 * Returns current gyroscope heading.
	 * 
	 * @return Gyro heading.
	 */
	public double getHeading() {
		return Utilities.formatAngle(purpleSensor.getAngle() + offset);
	}

	/**
	 * Zeroes the gyroscope heading.
	 */
	public void zeroHeading() {
		purpleSensor.zeroYaw();
	}
	
	public void setHeadingOffset (double offset) {
		this.offset = offset;
	}

	/**
	 * Returns whether or not the robot is tipping, based on the gyroscope
	 * readings and the angle threshold specified in {@link Constant}.
	 * 
	 * @return Whether the robot is tipping.
	 */
	public boolean isTipped() {
		return Math.abs(Utilities.angleDifference(0, purpleSensor.getPitch())) > Constant.kTIPPING_THRESHOLD.get()
				|| Math.abs(Utilities.angleDifference(0, purpleSensor.getRoll())) > Constant.kTIPPING_THRESHOLD.get();
	}

	/**
	 * Prints out gyro values for testing
	 */
	public void gyroTest() {
		System.out.println("Pitch: " + Math.round(purpleSensor.getPitch()) + " Roll: "
				+ Math.round(purpleSensor.getRoll()) + " Yaw: " + Math.round(purpleSensor.getYaw()));

	}

	// ==== LIGHTS ====
	private I2C i2cBus;
	static String rioDuinoStr;
	DriverStation ds = DriverStation.getInstance();

	public void lightsInit() {
		i2cBus = new I2C(I2C.Port.kOnboard, 4);
	}

	public void sendString(String writeStr) {
		char[] CharArray = writeStr.toCharArray();
		byte[] WriteData = new byte[CharArray.length];
		for (int i = 0; i < CharArray.length; i++) {
			WriteData[i] = (byte) CharArray[i];
		}
		try {
			i2cBus.transaction(WriteData, WriteData.length, null, 0);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void updateLights() {
		if (ds.isAutonomous()) {
			// When robot is in auto
			if (ds.getAlliance() == DriverStation.Alliance.Blue) {

				rioDuinoStr = "autoInitBlue";
			} else if (ds.getAlliance() == DriverStation.Alliance.Red) {

				rioDuinoStr = "autoInitRed";
			} else {

				rioDuinoStr = "autoInitInvalid";
			}
		} else if (ds.isDisabled()) {
			// robot disabled
			rioDuinoStr = "disabledInit";
		} else if (ds.isTest()) {
			// robot in test mode
			rioDuinoStr = "autoInitInvalid";
		} else {
			// robot in teleop
			if (Robot.drivetrain.isReverseMode()) {
				rioDuinoStr = "Forward";
			} else {
				rioDuinoStr = "Backward";
			}
		}
//		System.out.println(rioDuinoStr);
		sendString(rioDuinoStr);
	}

	// ==== POWER DISTRIBUTION PANEL ====
	/**
	 * Gets the current draw from a given power distribution panel channel.
	 * 
	 * @param channel
	 *            The channel number on the PDP.
	 * @return The current draw.
	 */
	public double getCurrent(int channel) {
		return pdp.getCurrent(channel);
	}

}
