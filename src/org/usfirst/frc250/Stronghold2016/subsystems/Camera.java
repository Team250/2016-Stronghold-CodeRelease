// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// Modified from https://github.com/Merfoo/MultiCamera

package org.usfirst.frc250.Stronghold2016.subsystems;

import org.usfirst.frc250.Stronghold2016.RobotMap;

import com.ni.vision.NIVision;
import com.ni.vision.NIVision.Image;
import com.ni.vision.VisionException;

import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.vision.USBCamera;

/**
 *
 */
public class Camera extends Subsystem {

	private USBCamera frontCamera = RobotMap.frontCamera;
	private USBCamera backCamera = RobotMap.backCamera;
	private boolean isReversed = false;
	private Image frame = NIVision.imaqCreateImage(NIVision.ImageType.IMAGE_RGB, 0);
	private CameraServer server = CameraServer.getInstance();
	private boolean cameraWorking = false;

	public void initDefaultCommand() {
		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}
	
	public Camera() {
		try {
			server.setQuality(50);
			frontCamera.openCamera();
			backCamera.openCamera();
			frontCamera.setSize(640, 360);
			backCamera.setSize(640, 360);
			frontCamera.startCapture();
			cameraWorking = true;
		} catch (VisionException e) {
			System.out.println(e);
			cameraWorking = false;
		}
	}
	
	public void reinit () {
		frontCamera.closeCamera();
		backCamera.closeCamera();
		frontCamera.openCamera();
		backCamera.openCamera();
		frontCamera.startCapture();
		isReversed = false;
		cameraWorking = true;
	}

	/**
	 * Switch to the opposite camera from the current one.
	 */
	public void switchCam() {
		if (isReversed) {
			backCamera.stopCapture();
			frontCamera.startCapture();
		} else {
			frontCamera.stopCapture();
			backCamera.startCapture();
		}
		isReversed = !isReversed;
	}

	/**
	 * Get the image from the current camera and give it to the server
	 */
	public void updateCam() {
		try {
			if (isReversed) {
				backCamera.getImage(frame);
			} else {
				frontCamera.getImage(frame);
			}
			server.setImage(frame);
			cameraWorking = true;
		} catch (VisionException e) {
			System.out.println(e);
			cameraWorking = false;
		}
	}

	public boolean isCameraWorking() {
		return cameraWorking;
	}
}
