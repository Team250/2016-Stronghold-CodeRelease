// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.Stronghold2016;

import org.usfirst.frc250.Stronghold2016.commands.auto.*;
import org.usfirst.frc250.Stronghold2016.commands.defenseArm.*;
import org.usfirst.frc250.Stronghold2016.commands.driving.*;
import org.usfirst.frc250.Stronghold2016.commands.intakeArm.*;
import org.usfirst.frc250.Stronghold2016.commands.other.*;
import org.usfirst.frc250.Stronghold2016.commands.rollers.*;
import org.usfirst.frc250.Stronghold2016.commands.shooter.*;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.buttons.JoystickButton;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * This class is the glue that binds the controls on the physical operator
 * interface to the commands and command groups that allow control of the robot.
 */
public class OI {
	//// CREATING BUTTONS
	// One type of button is a joystick button which is any button on a
	//// joystick.
	// You create one by telling it which joystick it's on and which button
	// number it is.
	// Joystick stick = new Joystick(port);
	// Button button = new JoystickButton(stick, buttonNumber);

	// There are a few additional built in buttons you can use. Additionally,
	// by subclassing Button you can create custom triggers and bind those to
	// commands the same as any other Button.

	//// TRIGGERING COMMANDS WITH BUTTONS
	// Once you have a button, it's trivial to bind it to a button in one of
	// three ways:

	// Start the command when the button is pressed and let it run the command
	// until it is finished as determined by it's isFinished method.
	// button.whenPressed(new ExampleCommand());

	// Run the command while the button is being held down and interrupt it once
	// the button is released.
	// button.whileHeld(new ExampleCommand());

	// Start the command when the button is released and let it run the command
	// until it is finished as determined by it's isFinished method.
	// button.whenReleased(new ExampleCommand());

	SendableChooser autoChooser;
	SendableChooser forwardChooser;

	public Joystick driver;
	public JoystickButton a_, b_, y_, leftBumper_, rightBumper_;

	public Joystick manipulator;
	public JoystickButton a, b, x, y, leftBumper, rightBumper, select;

	public static final int
	// Driver
	leftDriveAxis = 1, // left up-down axis
			rightDriveAxis = 5, // right up-down axis
			defenseArmLeftAxis = 2, // left trigger
			defenseArmRightAxis = 3, // right trigger
			// Manipulator
			intakeArmAxis = 1; // left up-down axis

	public OI() {
		manipulator = new Joystick(1);
		select = new JoystickButton(manipulator, 7);
		rightBumper = new JoystickButton(manipulator, 6);
		leftBumper = new JoystickButton(manipulator, 5);
		y = new JoystickButton(manipulator, 4);
		x = new JoystickButton(manipulator, 3);
		b = new JoystickButton(manipulator, 2);
		a = new JoystickButton(manipulator, 1);

		a.whenPressed(new Shoot());
		b.whileHeld(new Eject());
		x.whenPressed(new PullInBall());
		y.whenPressed(new Shoot(true));
		rightBumper.whileHeld(new RaiseDeflector());
		leftBumper.whileHeld(new LowerDeflector());
		select.whenPressed(new StopManipulatorThings());

		driver = new Joystick(0);
		leftBumper_ = new JoystickButton(driver, 5);
		rightBumper_ = new JoystickButton(driver, 6);
		y_ = new JoystickButton(driver, 4);
		b_ = new JoystickButton(driver, 2);
		a_ = new JoystickButton(driver, 1);

		a_.whenPressed(new SetReverseMode());
		b_.whenPressed(new HeadingCorrection());
		y_.whenPressed(new RaiseDefenseArmFast());
		leftBumper_.whenPressed(new SwitchCamera());
		leftBumper_.whenReleased(new SwitchCamera());
		rightBumper_.whileHeld(new Coast());

		// SmartDashboard
		forwardChooser = new SendableChooser();
		forwardChooser.addDefault("Defense arm forward", false);
		forwardChooser.addObject("Intake arm forward", true);
		SmartDashboard.putData("Front", forwardChooser);

		autoChooser = new SendableChooser();
		autoChooser.addDefault("Do nothing", new DoNothingAuto());
		autoChooser.addObject("Forward", new ForwardAuto());
		autoChooser.addObject("Forward and back", new ForwardAndBackAuto());
		autoChooser.addObject("Forward and lower deflector", new ForwardAndLowerDeflectorAuto());
		autoChooser.addObject("Forward and center intake arm", new ForwardAndLowerArmAuto());
		autoChooser.addObject("Forward, lower deflector, and center intake arm",
				new ForwardAndLowerArmAndDeflectorAuto());
		autoChooser.addObject("Longer forward (moat, rough terrain)", new LongerForwardAuto());
		autoChooser.addObject("Portcullis", new PortucullisAuto());
		autoChooser.addObject("Low bar, turn, and eject", new ForwardTurnAndEjectAuto());
		autoChooser.addObject("Low bar, turn and shoot", new ForwardTurnRightAndShootAuto());
		autoChooser.addObject("Position five turn and shoot", new ForwardTurnLeftAndShootAuto());
		autoChooser.addObject("Spy box shot", new SpyBoxShootAuto());
		SmartDashboard.putData("Autonomous", autoChooser);

		SmartDashboard.putData("Switch camera", new SwitchCamera());
		SmartDashboard.putData("Restart camera", new RestartCamera());
		SmartDashboard.putData("Zero deflector", new ZeroDeflectorEncoder());

		SmartDashboard.putNumber("Flywheel input", 5000);
		// SmartDashboard.putNumber("Intake arm input", 0);
		// SmartDashboard.putData("IntakeArmToSetpoint",
		// new IntakeArmToSetpoint(SmartDashboard.getNumber("Intake arm
		// input")));
		SmartDashboard.putNumber("Deflector position input", Constant.kDEFLECTOR_FAR_SHOOTING_POSITION.get());
		SmartDashboard.putNumber("Deflector overshoot input", Constant.kDEFLECTOR_POSITION_COMPENSATION.get());
		SmartDashboard.putData("Deflector to position", new DeflectorToPositionWithOvershoot(true));
		SmartDashboard.putData("Shoot w\\ inputs", new Shoot(false, true));
	}

	public void SmartDashboardPush() {
		SmartDashboard.putNumber("Flywheel speed", (int) Robot.shooter.getWheelSpeed());
		SmartDashboard.putNumber("Deflector Encoder", (int) Robot.shooter.getDeflectorPosition());
		SmartDashboard.putBoolean("Reverse Mode", Robot.drivetrain.isReverseMode());
		SmartDashboard.putNumber("Heading", Utilities.round(Robot.miscellany.getHeading()));
		SmartDashboard.putBoolean("Are the cameras working?", Robot.camera.isCameraWorking());
		SmartDashboard.putBoolean("Inner photo gate", Robot.rollers.isInnerPhotoGateBroken());
		SmartDashboard.putBoolean("Outer photo gate", Robot.rollers.isOuterPhotoGateBroken());
		SmartDashboard.putString("Ball?", Robot.rollers.isInnerPhotoGateBroken() ? "Ball!" : "");
		SmartDashboard.putNumber("Intake arm encoder", Utilities.round(Robot.intakeArm.getArmPosition()));
	}
}
